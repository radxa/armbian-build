From 6d68bbaa78882b59aaacf31c2f1cad5589982eff Mon Sep 17 00:00:00 2001
From: Finley Xiao <finley.xiao@rock-chips.com>
Date: Tue, 29 Sep 2020 17:53:27 +0800
Subject: [PATCH 04/19] rockchip: otp: Add support for rk3308bs

Change-Id: I19e42bb3aac8b205da77f49c6890f0f17d022cb3
Signed-off-by: Finley Xiao <finley.xiao@rock-chips.com>
---
 drivers/misc/rockchip-otp.c | 179 ++++++++++++++++++++++++++++++++++++++++++--
 include/rockchip-otp.h      |  19 ++++-
 2 files changed, 191 insertions(+), 7 deletions(-)

diff --git a/drivers/misc/rockchip-otp.c b/drivers/misc/rockchip-otp.c
index 2e3d11e..576b9dc 100644
--- a/drivers/misc/rockchip-otp.c
+++ b/drivers/misc/rockchip-otp.c
@@ -4,14 +4,21 @@
  */
 
 #include <common.h>
+#include <asm/arch/cpu.h>
 #include <asm/io.h>
 #include <command.h>
 #include <dm.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
+#include <linux/iopoll.h>
 #include <misc.h>
 #include <rockchip-otp.h>
 
+struct otp_data {
+	int (*init)(struct udevice *dev);
+	int (*read)(struct udevice *dev, int offset, void *buf, int size);
+};
+
 static int rockchip_otp_wait_status(struct rockchip_otp_platdata *otp,
 				    u32 flag)
 {
@@ -91,16 +98,149 @@ read_end:
 	return ret;
 }
 
+static int rk3308bs_otp_wait_status(struct rockchip_otp_platdata *otp, u32 flag)
+{
+	int delay = OTPC_TIMEOUT;
+
+	while (!(readl(otp->base + OTPC_IRQ_ST) & flag)) {
+		udelay(1);
+		delay--;
+		if (delay <= 0) {
+			printf("%s: wait init status timeout\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	/* clean int status */
+	writel(flag, otp->base + OTPC_IRQ_ST);
+
+	return 0;
+}
+
+static int rk3308bs_otp_active(struct rockchip_otp_platdata *otp)
+{
+	int ret = 0;
+	u32 mode;
+
+	mode = readl(otp->base + OTPC_MODE_CTRL);
+
+	switch (mode) {
+	case OTPC_DEEP_STANDBY:
+		writel(OTPC_STANDBY, otp->base + OTPC_MODE_CTRL);
+		ret = rk3308bs_otp_wait_status(otp, OTPC_DP2STB_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait dp2stb\n");
+			return ret;
+		}
+	case OTPC_STANDBY:
+		writel(OTPC_ACTIVE, otp->base + OTPC_MODE_CTRL);
+		ret = rk3308bs_otp_wait_status(otp, OTPC_STB2ACT_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait stb2act\n");
+			return ret;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int rk3308bs_otp_standby(struct rockchip_otp_platdata *otp)
+{
+	int ret = 0;
+	u32 mode;
+
+	mode = readl(otp->base + OTPC_MODE_CTRL);
+
+	switch (mode) {
+	case OTPC_ACTIVE:
+		writel(OTPC_STANDBY, otp->base + OTPC_MODE_CTRL);
+		ret = rk3308bs_otp_wait_status(otp, OTPC_ACT2STB_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait act2stb\n");
+			return ret;
+		}
+	case OTPC_STANDBY:
+		writel(OTPC_DEEP_STANDBY, otp->base + OTPC_MODE_CTRL);
+		ret = rk3308bs_otp_wait_status(otp, OTPC_STB2DP_IRQ_ST);
+		if (ret < 0) {
+			dev_err(otp->dev, "timeout during wait stb2dp\n");
+			return ret;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int rockchip_rk3308bs_otp_read(struct udevice *dev, int offset,
+				      void *buf, int size)
+{
+	struct rockchip_otp_platdata *otp = dev_get_platdata(dev);
+	unsigned int addr_start, addr_end, addr_offset, addr_len;
+	u32 out_value;
+	u8 *buffer;
+	int ret = 0, i = 0;
+
+	if (offset > RK3308BS_MAX_BYTES - 1)
+		return -ENOMEM;
+	if (offset + size > RK3308BS_MAX_BYTES)
+		size = RK3308BS_MAX_BYTES - offset;
+
+	ret = rk3308bs_otp_active(otp);
+	if (ret)
+		goto out;
+
+	addr_start = rounddown(offset, RK3308BS_NBYTES) / RK3308BS_NBYTES;
+	addr_end = roundup(offset + size, RK3308BS_NBYTES) / RK3308BS_NBYTES;
+	addr_offset = offset % RK3308BS_NBYTES;
+	addr_len = addr_end - addr_start;
+
+	buffer = calloc(1, sizeof(*buffer) * addr_len * RK3308BS_NBYTES);
+	if (!buffer) {
+		ret = -ENOMEM;
+		goto read_end;
+	}
+
+	while (addr_len--) {
+		writel(OTPC_TRANS_NUM, otp->base + OTPC_REPR_RD_TRANS_NUM);
+		writel(addr_start++, otp->base + OTPC_ACCESS_ADDR);
+		writel(OTPC_READ_ACCESS, otp->base + OTPC_MODE_CTRL);
+		ret = rk3308bs_otp_wait_status(otp, OTPC_RDM_IRQ_ST);
+		if (ret < 0) {
+			printf("timeout during wait rd\n");
+			goto read_end;
+		}
+		out_value = readl(otp->base + OTPC_RD_DATA);
+		memcpy(&buffer[i], &out_value, RK3308BS_NBYTES);
+		i += RK3308BS_NBYTES;
+	}
+	memcpy(buf, buffer + addr_offset, size);
+
+read_end:
+	kfree(buffer);
+	rk3308bs_otp_standby(otp);
+out:
+	return ret;
+}
+
 static int rockchip_otp_read(struct udevice *dev, int offset,
 			     void *buf, int size)
 {
-	OTP_READ otp_read = NULL;
+	struct otp_data *data;
 
-	otp_read = (OTP_READ)dev_get_driver_data(dev);
-	if (!otp_read)
+	data = (struct otp_data *)dev_get_driver_data(dev);
+	if (!data)
 		return -ENOSYS;
 
-	return (*otp_read)(dev, offset, buf, size);
+	if (soc_is_rk3308bs())
+		return rockchip_rk3308bs_otp_read(dev, offset, buf, size);
+
+	return data->read(dev, offset, buf, size);
 }
 
 static const struct misc_ops rockchip_otp_ops = {
@@ -116,14 +256,40 @@ static int rockchip_otp_ofdata_to_platdata(struct udevice *dev)
 	return 0;
 }
 
+static int rockchip_otp_probe(struct udevice *dev)
+{
+	struct otp_data *data;
+
+	data = (struct otp_data *)dev_get_driver_data(dev);
+	if (!data)
+		return -EINVAL;
+
+	if (data->init)
+		return data->init(dev);
+
+	return 0;
+}
+
+static const struct otp_data px30_data = {
+	.read = rockchip_px30_otp_read,
+};
+
+static const struct otp_data rk3308bs_data = {
+	.read = rockchip_rk3308bs_otp_read,
+};
+
 static const struct udevice_id rockchip_otp_ids[] = {
 	{
 		.compatible = "rockchip,px30-otp",
-		.data = (ulong)&rockchip_px30_otp_read,
+		.data = (ulong)&px30_data,
 	},
 	{
 		.compatible = "rockchip,rk3308-otp",
-		.data = (ulong)&rockchip_px30_otp_read,
+		.data = (ulong)&px30_data,
+	},
+	{
+		.compatible = "rockchip,rk3308bs-otp",
+		.data = (ulong)&rk3308bs_data,
 	},
 	{}
 };
@@ -135,4 +301,5 @@ U_BOOT_DRIVER(rockchip_otp) = {
 	.ops = &rockchip_otp_ops,
 	.ofdata_to_platdata = rockchip_otp_ofdata_to_platdata,
 	.platdata_auto_alloc_size = sizeof(struct rockchip_otp_platdata),
+	.probe = rockchip_otp_probe,
 };
diff --git a/include/rockchip-otp.h b/include/rockchip-otp.h
index 71fbbf5..f6d0d59 100644
--- a/include/rockchip-otp.h
+++ b/include/rockchip-otp.h
@@ -42,7 +42,24 @@
 
 #define OTPC_TIMEOUT			10000
 
-typedef int (*OTP_READ)(struct udevice *dev, int offset, void *buf, int size);
+#define OTPC_MODE_CTRL			0x2000
+#define OTPC_IRQ_ST			0x2008
+#define OTPC_ACCESS_ADDR		0x200c
+#define OTPC_RD_DATA			0x2010
+#define OTPC_REPR_RD_TRANS_NUM		0x2020
+#define OTPC_DEEP_STANDBY		0x0
+#define OTPC_STANDBY			0x1
+#define OTPC_ACTIVE			0x2
+#define OTPC_READ_ACCESS		0x3
+#define OTPC_TRANS_NUM			0x1
+#define OTPC_RDM_IRQ_ST			BIT(0)
+#define OTPC_STB2ACT_IRQ_ST		BIT(7)
+#define OTPC_DP2STB_IRQ_ST		BIT(8)
+#define OTPC_ACT2STB_IRQ_ST		BIT(9)
+#define OTPC_STB2DP_IRQ_ST		BIT(10)
+#define RK3308BS_NBYTES			4
+#define RK3308BS_MAX_BYTES		0x80
+#define RK3308BS_NO_SECURE_OFFSET	224
 
 struct rockchip_otp_platdata {
 	void __iomem *base;
-- 
2.7.4

