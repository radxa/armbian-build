From 00cf71e49eeff094a486e26ee272b07e397d4561 Mon Sep 17 00:00:00 2001
From: Finley Xiao <finley.xiao@rock-chips.com>
Date: Sat, 25 Sep 2021 15:01:47 +0800
Subject: [PATCH 06/19] rockchip: rk3308: Add support to change thermal
 configure

Change-Id: I8d896fad932c86d9bd00bcca2f2c2d290fdaaa9d
Signed-off-by: Finley Xiao <finley.xiao@rock-chips.com>
---
 arch/arm/mach-rockchip/rk3308/rk3308.c | 55 ++++++++++++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/arch/arm/mach-rockchip/rk3308/rk3308.c b/arch/arm/mach-rockchip/rk3308/rk3308.c
index ac856fa..ab62457 100644
--- a/arch/arm/mach-rockchip/rk3308/rk3308.c
+++ b/arch/arm/mach-rockchip/rk3308/rk3308.c
@@ -211,8 +211,10 @@ static int fdt_fixup_cpu_opp_table(const void *blob)
 	int len;
 	u32 phandle;
 	u32 *pp;
+	u32 val;
 	bool is_opp_enabled;
 
+	/* Replace opp table */
 	opp_node = fdt_path_offset(blob, "/rk3308bs-cpu0-opp-table");
 	if (opp_node < 0) {
 		printf("Failed to get rk3308bs-cpu0-opp-table node\n");
@@ -245,6 +247,7 @@ static int fdt_fixup_cpu_opp_table(const void *blob)
 		return -EINVAL;
 	}
 
+	/* Enable 1296MHz and 1200MHz */
 	is_opp_enabled = false;
 	sub_node = fdt_subnode_offset(blob, old_opp_node, "opp-1296000000");
 	if (sub_node >= 0) {
@@ -275,6 +278,31 @@ static int fdt_fixup_cpu_opp_table(const void *blob)
 			printf("Failed to set 1200 okay\n");
 	}
 
+	/* Add high temp configure */
+	pp = (u32 *)fdt_getprop(blob, old_opp_node, "rockchip,high-temp", &len);
+	if (pp) {
+		val = fdt32_to_cpu(*pp);
+		pp = (u32 *)fdt_getprop(blob, opp_node,
+					"rockchip,high-temp", &len);
+		if (!pp) {
+			if (fdt_setprop_u32((void *)blob, opp_node,
+					    "rockchip,high-temp", val))
+				printf("Failed to set high temp prop\n");
+		}
+	}
+	pp = (u32 *)fdt_getprop(blob, old_opp_node,
+				"rockchip,high-temp-max-volt", &len);
+	if (pp) {
+		val = fdt32_to_cpu(*pp);
+		pp = (u32 *)fdt_getprop(blob, opp_node,
+					"rockchip,high-temp-max-volt", &len);
+		if (!pp) {
+			if (fdt_setprop_u32((void *)blob, opp_node,
+					    "rockchip,high-temp-max-volt", val))
+				printf("Failed to set high temp max volt prop\n");
+		}
+	}
+
 	return 0;
 }
 
@@ -311,11 +339,38 @@ static int fdt_fixup_dmc_opp_table(const void *blob)
 	return 0;
 }
 
+static int fdt_fixup_thermal_zones(const void *blob)
+{
+	int thermal_node;
+	int len;
+	u32 *pp;
+	u32 val;
+
+	thermal_node = fdt_path_offset(blob, "/thermal-zones/soc-thermal");
+	if (thermal_node < 0) {
+		printf("Failed to get soc thermal node\n");
+		return -EINVAL;
+	}
+
+	pp = (u32 *)fdt_getprop(blob, thermal_node,
+				"rk3308bs-sustainable-power", &len);
+	if (pp) {
+		val = fdt32_to_cpu(*pp);
+		pp = (u32 *)fdt_getprop(blob, thermal_node,
+					"sustainable-power", &len);
+		if (pp)
+			pp[0] = cpu_to_fdt32(val);
+	}
+
+	return 0;
+}
+
 int rk_board_fdt_fixup(const void *blob)
 {
 	if (soc_is_rk3308bs()) {
 		fdt_fixup_cpu_opp_table(blob);
 		fdt_fixup_dmc_opp_table(blob);
+		fdt_fixup_thermal_zones(blob);
 	}
 
 	return 0;
-- 
2.7.4

